<body>
  <h1>Europa XS Build Log</h1>

  <div id="sort-controls">
    <div id="sort-top-row">
      <label for="category-sort">Sort categories:</label>
      <select id="category-sort">
        <option value="date-desc" selected>Date (Newest → Oldest)</option>
        <option value="date-asc">Date (Oldest → Newest)</option>
        <option value="category-asc">Category (A → Z)</option>
        <option value="category-desc">Category (Z → A)</option>
      </select>

      <label for="jump-to-category">Jump to category:</label>
      <select id="jump-to-category"></select>
    </div>

    <div>
      <label for="entry-sort">Sort entries within category:</label>
      <select id="entry-sort">
        <option value="date-desc" selected>Date (Newest → Oldest)</option>
        <option value="date-asc">Date (Oldest → Newest)</option>
      </select>
    </div>
  </div>

  <div id="log-container"></div>

  <button id="back-to-top">↑ Back to Top</button>

  <script>
    // --- Smooth Scroll for Back to Top Button ---
    document.getElementById('back-to-top').addEventListener('click', () => {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // --- Build Log Data (fetched or preloaded externally) ---
    async function fetchLogData() {
      const response = await fetch('logData.json');
      return await response.json();
    }

    const logContainer = document.getElementById('log-container');
    const categorySortSelect = document.getElementById('category-sort');
    const entrySortSelect = document.getElementById('entry-sort');
    const jumpToSelect = document.getElementById('jump-to-category');

    let groupedLogs = {};

    // --- Render Categories and Entries ---
    function renderLogs(grouped) {
      logContainer.innerHTML = '';
      for (const [category, entries] of Object.entries(grouped)) {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'category';
        categoryDiv.id = category.replace(/\s+/g, '-');

        const categoryHeader = document.createElement('h2');
        categoryHeader.textContent = category;
        categoryDiv.appendChild(categoryHeader);

        for (const entry of entries) {
          const entryDiv = document.createElement('div');
          entryDiv.className = 'entry';

          const title = document.createElement('h3');
          title.textContent = entry.title;
          entryDiv.appendChild(title);

          const date = document.createElement('p');
          date.textContent = `Date: ${entry.date}`;
          entryDiv.appendChild(date);

          const time = document.createElement('p');
          time.textContent = `Time spent: ${entry.time}`;
          entryDiv.appendChild(time);

          const desc = document.createElement('p');
          desc.textContent = entry.description;
          entryDiv.appendChild(desc);

          if (entry.photos && entry.photos.length) {
            const photosDiv = document.createElement('div');
            photosDiv.className = 'photos';
            for (const photo of entry.photos) {
              const img = document.createElement('img');
              img.src = photo.url;
              img.alt = photo.caption;
              img.title = photo.caption;
              photosDiv.appendChild(img);
            }
            entryDiv.appendChild(photosDiv);
          }

          categoryDiv.appendChild(entryDiv);
        }

        logContainer.appendChild(categoryDiv);
      }
    }

    // --- Sorting Logic ---
    function sortCategories(order) {
      let categories = Object.keys(groupedLogs);
      switch (order) {
        case 'category-asc':
          categories.sort();
          break;
        case 'category-desc':
          categories.sort().reverse();
          break;
        case 'date-asc':
          categories.sort((a, b) => new Date(groupedLogs[a][0].date) - new Date(groupedLogs[b][0].date));
          break;
        case 'date-desc':
          categories.sort((a, b) => new Date(groupedLogs[b][0].date) - new Date(groupedLogs[a][0].date));
          break;
      }

      const sortedGrouped = {};
      for (const cat of categories) sortedGrouped[cat] = groupedLogs[cat];
      renderLogs(sortedGrouped);
    }

    function sortEntries(order) {
      for (const cat in groupedLogs) {
        groupedLogs[cat].sort((a, b) =>
          order === 'date-asc'
            ? new Date(a.date) - new Date(b.date)
            : new Date(b.date) - new Date(a.date)
        );
      }
      sortCategories(categorySortSelect.value);
    }

    // --- Populate Jump-to Dropdown ---
    function populateJumpTo() {
      const categories = Object.keys(groupedLogs).sort((a, b) => a.localeCompare(b));
      jumpToSelect.innerHTML = '';
      for (const category of categories) {
        const option = document.createElement('option');
        option.value = category.replace(/\s+/g, '-');
        option.textContent = category;
        jumpToSelect.appendChild(option);
      }
    }

    jumpToSelect.addEventListener('change', () => {
      categorySortSelect.value = 'category-asc'; // keep consistent alphabetical view
      sortCategories('category-asc');
      const selectedId = jumpToSelect.value;
      const section = document.getElementById(selectedId);
      if (section) section.scrollIntoView({ behavior: 'smooth' });
    });

    // --- Event Listeners ---
    categorySortSelect.addEventListener('change', e => sortCategories(e.target.value));
    entrySortSelect.addEventListener('change', e => sortEntries(e.target.value));

    // --- Initialize Page ---
    fetchLogData().then(data => {
      groupedLogs = data;
      populateJumpTo();
      sortCategories('date-desc');
    });
  </script>
</body>
